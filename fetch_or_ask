#!/bin/bash

fetch_or_ask() {
    local parameters=("$@")
    local env_file="/root/.env"
    local server_id=""
    local value=""
    local existing_value=""
    local prompt=""

    # Проверка наличия файла .env и создание его при отсутствии
    if [[ ! -f $env_file ]]; then
        touch "$env_file"
    fi

    # Считывание server_id из файла безопасным способом
    server_id=$(grep "^server_id=" "$env_file" | awk -F= '{print $2}' | xargs)

    # Проверка server_id на длину и специальные символы
    if [[ ${#server_id} -gt 50 || "$server_id" =~ [^a-zA-Z0-9_] ]]; then
        echo "Invalid server_id."
        exit 1
    fi

    # Если server_id отсутствует, запрашиваем его у пользователя
    while [[ -z $server_id ]]; do
        read -p "Enter server_id: " server_id
    done

    # Сохраняем server_id в файл .env, если его там не было
    if ! grep -q "server_id" "$env_file"; then
        echo "server_id=$server_id" >> "$env_file"
    fi

    # Если функция вызвана без параметров, возвращаем server_id
    if [ "$#" -eq 0 ]; then
        echo "$server_id"
        return
    fi

    # Формируем путь к каталогу и имя файла
    local directory="./data"
    local filename=""

    for param in "${parameters[@]}"; do
        directory+="/$param"
        filename+="$param"
    done

    # Защита от пустого filename
    if [[ -z $filename ]]; then
        echo "Filename is empty."
        exit 1
    fi

    mkdir -p "$directory"  # создаем директорию, если она не существует

    # Проверяем, есть ли уже значение в файле безопасным способом
    if [[ -f "$directory/$filename" ]]; then
        existing_value=$(grep "^$server_id" "$directory/$filename" | awk '{print $2}' | xargs)
    fi

    if [[ -n $existing_value ]]; then
        value=$existing_value
    else
        while : ; do  # бесконечный цикл
            read -p "Enter value for $filename (or press Enter to skip): " value
            # Проверка на длину и специальные символы в value
            if [[ ${#value} -gt 100 || "$value" =~ [^a-zA-Z0-9_] ]]; then
                echo "Invalid input."
                continue  # возвращает в начало цикла
            elif [[ -z $value ]]; then
                echo "Skipping the input for $filename."
                return  # прерывает выполнение функции
            else
                break  # выходит из цикла, если значение не пусто
            fi
        done

        # Обновляем значение в файле
        echo "$server_id $value" >> "$directory/$filename"
    fi

    # Экспортируем переменную в текущем сеансе
    export "$filename=$value"

    # Возвращаем значение
    echo "$value"
}
